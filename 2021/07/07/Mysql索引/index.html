<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/eprofile-data.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/eprofile-data.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic%7CRoboto+Slab:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="next-config" data-name="main" type="application/json">{&quot;hostname&quot;:&quot;sys-spearmint.github.io&quot;,&quot;root&quot;:&quot;&#x2F;&quot;,&quot;images&quot;:&quot;&#x2F;images&quot;,&quot;scheme&quot;:&quot;Gemini&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;},&quot;path&quot;:&quot;&#x2F;search.xml&quot;,&quot;localsearch&quot;:{&quot;enable&quot;:true,&quot;trigger&quot;:&quot;auto&quot;,&quot;top_n_per_article&quot;:1,&quot;unescape&quot;:false,&quot;preload&quot;:false}}</script>
<meta name="description" content="前言">
<meta property="og:type" content="article">
<meta property="og:title" content="Mysql Index">
<meta property="og:url" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/index.html">
<meta property="og:site_name" content="spearmint的博客">
<meta property="og:description" content="前言">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830813.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830800.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830812.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830801.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830802.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830803.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830804.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830805.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830806.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830807.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830808.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830809.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830810.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830814.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830815.png">
<meta property="og:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830811.png">
<meta property="article:published_time" content="2021-07-07T15:00:00.000Z">
<meta property="article:modified_time" content="2021-08-06T15:00:00.000Z">
<meta property="article:author" content="spearmint">
<meta property="article:tag" content="Mysql">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830813.png">


<link rel="canonical" href="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/">



<script class="next-config" data-name="page" type="application/json">{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;,&quot;comments&quot;:true,&quot;permalink&quot;:&quot;https:&#x2F;&#x2F;sys-spearmint.github.io&#x2F;2021&#x2F;07&#x2F;07&#x2F;Mysql%E7%B4%A2%E5%BC%95&#x2F;&quot;,&quot;path&quot;:&quot;2021&#x2F;07&#x2F;07&#x2F;Mysql索引&#x2F;&quot;,&quot;title&quot;:&quot;Mysql Index&quot;}</script>

<script class="next-config" data-name="calendar" type="application/json">&quot;&quot;</script>
<title>Mysql Index | spearmint的博客</title><script src="/js/config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="spearmint的博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">spearmint的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">4</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">6</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">索引是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%9B%BE%E8%A7%A3"><span class="nav-number">2.1.</span> <span class="nav-text">索引的图解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.2.</span> <span class="nav-text">索引类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E6%8E%A8%E6%BC%94"><span class="nav-number">2.3.</span> <span class="nav-text">索引存储模型推演</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">2.4.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91-BST-Binary-Search-Tree"><span class="nav-number">2.5.</span> <span class="nav-text">二叉查找树(BST Binary Search Tree)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL-Tree%EF%BC%89%EF%BC%88%E5%B7%A6%E6%97%8B%E3%80%81%E5%8F%B3%E6%97%8B%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">平衡二叉树（AVL Tree）（左旋、右旋）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AVL%E6%A0%91%E7%94%A8%E4%BA%8E%E5%AD%98%E5%82%A8%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE"><span class="nav-number">2.7.</span> <span class="nav-text">AVL树用于存储索引数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%88B-Tree%EF%BC%89%EF%BC%88%E5%88%86%E8%A3%82%E3%80%81%E5%90%88%E5%B9%B6%EF%BC%89"><span class="nav-number">2.8.</span> <span class="nav-text">多路平衡查找树（B Tree）（分裂、合并）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-%E6%A0%91%EF%BC%88%E5%8A%A0%E5%BC%BA%E7%89%88%E5%A4%9A%E8%B7%AF%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89"><span class="nav-number">2.9.</span> <span class="nav-text">B+树（加强版多路平衡查找树）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-number">2.10.</span> <span class="nav-text">为什么不用红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%9C%9F%E7%9A%84%E6%98%AF%E7%94%A8%E7%9A%84B-Tree%E5%90%97"><span class="nav-number">2.11.</span> <span class="nav-text">索引方式：真的是用的B+Tree吗?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-Tree%E8%90%BD%E5%9C%B0%E5%BD%A2%E5%BC%8F"><span class="nav-number">3.</span> <span class="nav-text">B+Tree落地形式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL-%E6%9E%B6%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">MySQL 架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%87%E4%BB%B6"><span class="nav-number">3.2.</span> <span class="nav-text">MySQL数据存储文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MylSAM"><span class="nav-number">3.3.</span> <span class="nav-text">MylSAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB"><span class="nav-number">3.4.</span> <span class="nav-text">InnoDB</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.1.</span> <span class="nav-text">聚簇索引</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="nav-number">4.</span> <span class="nav-text">索引使用原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%97%E7%9A%84%E7%A6%BB%E6%95%A3%E5%BA%A6"><span class="nav-number">4.1.</span> <span class="nav-text">列的离散度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="nav-number">4.2.</span> <span class="nav-text">联合索引最左匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">4.2.1.</span> <span class="nav-text">如何创建联合索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">4.3.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%9D%A1%E4%BB%B6%E4%B8%8B%E6%8E%A8%EF%BC%88ICP%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">索引条件下推（ICP）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number">5.</span> <span class="nav-text">索引的创建与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA"><span class="nav-number">5.1.</span> <span class="nav-text">索引创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-number">5.2.</span> <span class="nav-text">索引失效</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q-amp-A"><span class="nav-number">6.</span> <span class="nav-text">Q &amp; A</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Q1%EF%BC%9A%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%E5%91%A2%EF%BC%9F"><span class="nav-number">6.1.</span> <span class="nav-text">Q1：哈希索引有什么特点呢？</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">spearmint</p>
  <div class="site-description" itemprop="description">没有理想何必远方</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/sys-spearmint" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;sys-spearmint" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fas fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/sys-spearmint" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="spearmint">
      <meta itemprop="description" content="没有理想何必远方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="spearmint的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Mysql Index
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-07-07 23:00:00" itemprop="dateCreated datePublished" datetime="2021-07-07T23:00:00+08:00">2021-07-07</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-08-06 23:00:00" itemprop="dateModified" datetime="2021-08-06T23:00:00+08:00">2021-08-06</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Mysql/" itemprop="url" rel="index"><span itemprop="name">Mysql</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>13k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><span id="more"></span>

<h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><h3 id="索引的图解"><a href="#索引的图解" class="headerlink" title="索引的图解"></a>索引的图解</h3><p>维基百科上对数据库索引的定义：数据库索引，是数据库管理系统(DBMS)中一个排序的数据结构，以协助快速查询、 更新数据库表中数据。</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830813.png">

<p>数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址。如果没有索引的话，我们要从500万行数据里面检索一条数据，只能依次遍历这张表的全部数据, 直到找到这条数据。但是我们有了索引之后，只需要在索引里面去检索这条数据就行了，因为它是一种 特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址以后，就可以拿到 数据了。</p>
<p>就像我们从一本500页的书里面去找特定的一小节的内容，肯定不可能从第一页开 始翻。那么这本书有专门的目录，它可能只有几页的内容，它是按页码来组织的，可以根 据拼音或者偏旁部首来查找，我们只要确定内容对应的页码，就能很快地找到我们想要 的内容。</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>那在我们的数据表上面，我们怎么去创建一个索引呢？我们打开工具<code>Navicat</code>，右键设计表，在索引的这个选项卡里面，我们可以创建索引。</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830800.png" alt="image-20210622005830808">

<p>第一个是索引的名称，第二个是索引的列，比如我们是要对id创建索引还是对name创建索引。后面两个很重要，一个叫索引类型。在<code>InnoDB</code>里面，索引类型有四种，全文索引（<code>FULLTEXT</code>）普通索引（<code>NORMAL</code>）、空间索引（<code>SPATIAL</code>）、唯一索引（<code>UNIQUE</code>）。</p>
<blockquote>
<p>主键索引是特殊的唯一 索引。</p>
</blockquote>
<p>普通(NORMAL)：也叫非唯一索引，是最普通的索引，没有任何的限制。</p>
<p>唯一 (UNIQUE)：唯一索弓|要求键值不能重复。另外需要注意的是，主键索引是一 种特殊的唯一索引，它还多了一个限制条件，要求键值不能为空，主键索引用primay key 创建。</p>
<p>全文(<code>FULLTEXT</code>)：针对比较大的数据，比如我们存放的是消息内容、一篇文章，有 几KB的数据的这种情况，如果要解决like査询在全文匹配的时候效率低的问题，可以创建全文索引。只有文本类型的字段才可以创建全文索引，比如<code>char</code>、<code>varchar</code>、<code>text</code>。</p>
<blockquote>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;select * fiom table where match(content) against(&#39;test&#39;IN NATURAL LANGUAGE MODE);</span><br></pre></td></tr></table></figure>

<p><code>MylSAM</code>和<code>InnoDB</code>支持全文索引。</p>
</blockquote>
<h3 id="索引存储模型推演"><a href="#索引存储模型推演" class="headerlink" title="索引存储模型推演"></a>索引存储模型推演</h3><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>《幸运52》有一个猜价格的游戏，限定时间之内猜中了就可以带回家。</p>
<p>在你报出价格之后主持人会告诉你低了还是高了如果价格在10000-30000之间，你会先猜多少？</p>
<p>一般人都会从2000开始猜。其实这个就是二分查找的一种思想，也叫折半查找，每一次，我们都把候选数据缩小了一半。如果数据已经排过序的话，这种方式效率比较高。 所以第一个,我们可以考虑用有序数组作为索引的数据结构。</p>
<p><strong>有序数组</strong>的等值查询和比较查询效率非常高，但是更新数据的时候会出现一个问题, 可能要挪动大量的数据(改变index),所以只适合存储静态的数据。</p>
<p>为了支持频繁的修改，比如插入数据，我们需要采用链表，<strong>链表</strong>的话，如果是单链 表，它的查找效率还是不够高。</p>
<p>所以，有没有可以使用二分査找的链表呢？</p>
<p>为了解决这个问题，BST (Binary Search Tree)也就是我们所说的二叉査找树诞生了。</p>
<h3 id="二叉查找树-BST-Binary-Search-Tree"><a href="#二叉查找树-BST-Binary-Search-Tree" class="headerlink" title="二叉查找树(BST Binary Search Tree)"></a>二叉查找树(BST Binary Search Tree)</h3><p><strong>特点</strong>：左子树所有的节点都小于父节点，右子树所有的节点都大于父节点。投影到平面以后，就是一个有序的线性表。</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830812.png" alt="image-20210622005830808">

<p>二叉查找树既能够实现快速查找，又能够实现快速插入。但是二叉查找树有一个问题：就是它的查找耗时是和这棵树的深度相关的，在最坏的情况下时间复杂度会退化成O(n)。</p>
<p>什么情况是最坏的情况呢？</p>
<p>还是刚才的这一批数字，如果我们插入的数据刚好是有序的，2、6、11、13、17、22。它会变成链表（我们把这种树叫做“斜树”），这种情况下不能达到加快检索速度的目的，和顺序查找效率是没有区别的。</p>
<p>造成它倾斜的原因是什么呢？</p>
<p>因为左右子树深度差太大，这棵树的左子树根本没有节点——也就是它不够平衡。所以，我们有没有左右子树深度相差不是那么大，更加平衡的树呢？这个就是平衡二叉树，叫做Balanced binary search trees，或者<code>AV</code>L树（<code>AVL</code>是发明这个数据结构的两位作者的名字简写：<code>G. M. Adelson-Velsky</code>和<code>E. M. Landis</code>）。</p>
<h3 id="平衡二叉树（AVL-Tree）（左旋、右旋）"><a href="#平衡二叉树（AVL-Tree）（左旋、右旋）" class="headerlink" title="平衡二叉树（AVL Tree）（左旋、右旋）"></a>平衡二叉树（AVL Tree）（左旋、右旋）</h3><p><code>AVL</code> Trees （<strong>Balanced</strong> binary search trees）</p>
<p>平衡二叉树的<strong>定义</strong>：左右子树深度差绝对值不能超过1。</p>
<p>是什么意思呢？比如左子树的深度是2,右子树的深度只能是1或者3。</p>
<p>这个时候我们再按顺序插入1、2、3、4、5、6,—定是这样，不会变成一棵“斜树“</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830801.png" alt="image-20210622005830808">

<p>那它的平衡是怎么做到的呢？怎么保证左右子树的深度差不能超过1呢？</p>
<p>插入1、2、3。我们注意看：当我们插入了 1、2之后，如果按照二叉查找树的定义，3肯定是要在 2的右边的，这个时候根节点1的右节点深度会变成2,但是左节点的深度是0,因为它 没有子节点，所以就会违反平衡二叉树的定义。</p>
<p>那应该怎么办呢？因为它是右节点下面接一个右节点，右-右型，所以这个时候我们 要把2提上去，这个操作叫做左旋。</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830802.png" alt="image-20210622005830808">

<p>同样的，如果我们插入7、6、5,这个时候会变成左左型，就会发生右旋操作，把6提上去。<br><img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830803.png" alt="image-20210622005830808"></p>
<p>所以为了保持平衡，AVL树在插入和更新数据的时候执行了一系列的计算和调整的 操作。</p>
<p>平衡的问题我们解决了，那么平衡二叉树作为索引怎么査询数据?</p>
<p>在平衡二叉树中，一个节点，它的大小是一个固定的单位，作为索引应该存储什么内容？</p>
<p>前面我们已经知道了，索引必须要存你建立索引的字段的值，叫做键值，比如id的值。还要存完整记录在磁盘上的地址。由于AVL树是二叉树，所以还要额外地存储左右子树的指针。</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830804.png" alt="image-20210622005830808">

<p>如图：</p>
<p>第一个是索引的键值。比如我们在id上面创建了一个索弓|,我在用where id =1的 条件查询的时候就会找到索引里面的id的这个键值。</p>
<p>第二个是数据的磁盘地址，因为索引的作用就是去查找数据的存放的地址。</p>
<p>第三个，因为是二叉树，它必须还要有左子节点和右子节点的引用，这样我们才能找到下一个节点。比如大于26的时候，走右边，到下一个树的节点，继续判断。</p>
<p>如果是这样存储数据的话，我们来看一下会有什么问题。</p>
<h3 id="AVL树用于存储索引数据"><a href="#AVL树用于存储索引数据" class="headerlink" title="AVL树用于存储索引数据"></a>AVL树用于存储索引数据</h3><p>首先，索引的数据，是放在硬盘上的。查看数据和索引的大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">CONCAT(ROUND(SUM(DATA_LENGTH&#x2F;1024&#x2F;1024),2),&#39;MB&#39;)  AS data_len, CONCAT(ROUND(SUM(INDEX_LENGTH&#x2F;1024&#x2F;1024),2),&#39;MB&#39;) AS index_len </span><br><span class="line">       from information_schema.TABLES</span><br><span class="line">where table_schema&#x3D;&#39;test&#39; and table_name&#x3D;&#39;user_innodb&#39;;</span><br></pre></td></tr></table></figure>

<p>当我们用树的结构来存储索引的时候，访问一个节点就要跟磁盘之间发生一次IO操作。<code>InnoDB</code>操作磁盘的最小的单位是一页(或者叫一个磁盘块)，大小是<code>16K</code>(16384 字节)。那么，一个树的节点必须设计成<code>16K</code>的大小，不然就会出现读不完或者读不够的情 况。如果我们一个节点只存一个键值+数据+引用，例如整形的字段，可能只用了十几个或者几十个字节，它远远达不到<code>16K</code>的容量。</p>
<p>因此，我们基于索引査找数据的时候，肯定是希望一次从磁盘加载很多的数据 到内存中进行比较，这样就可以尽快拿到完整的数据。如果一个节点只存1个这样的单元，就需要读更多的节点，发生更多的I/O操作。如果是机械硬盘时代，每次从磁盘读取数据需要<code>10ms</code>左右的寻址时间，交互次数 越多，消耗的时间就越多。</p>
<p>比如上面这张图，我们一张表里面有6条数据，当我们查询id = 66的时候，要查询 两个子节点，就需要跟磁盘交互3次，如果我们有几百万的数据呢？这个时间更加难以 估计。</p>
<p>我们怎么解决这个问题？</p>
<ul>
<li><p>第一个就是让每个节点存储更多的数据。</p>
</li>
<li><p>第二个，节点上的关键字的数量越多，我们的指与十数也越多，也就是意味着可以有 更多的分叉（我们把它叫做”路数”）。</p>
</li>
</ul>
<p>因为分叉数越多，树的深度就会减少（根节点是0）。这样，我们的树是不是从原来的高瘦高瘦的样子，变成了矮胖矮胖的样子？这个时候，我们的树就不再是二叉了，而是多叉，或者叫做多路。</p>
<h3 id="多路平衡查找树（B-Tree）（分裂、合并）"><a href="#多路平衡查找树（B-Tree）（分裂、合并）" class="headerlink" title="多路平衡查找树（B Tree）（分裂、合并）"></a>多路平衡查找树（B Tree）（分裂、合并）</h3><p>跟<code>AVL</code>树一样，B树在枝节点和叶子节点存储键值、数据地址、节点引用。</p>
<p><strong>特点</strong>：分叉数（路数）永远比关键字数多1。比如我们画的这棵树，每个节 点存储两个关键字，那么就会有三个指针指向三个子节点（当然肯定不只存3个这么少）。</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830805.png" alt="image-20210622005830808">

<p>B Tree的查找规则</p>
<p>比如我们要在这张表里面查找15。因为15小于17,走左边。因为15大于12,走右边。在磁盘块7里面就找到了15，只用了 3次IO。</p>
<p>这个是不是比AVL树效率更高呢？</p>
<p>那B Tree又是怎么实现一个节点存储多个关键字，还保持平衡的呢？跟AVL树有什么区别？</p>
<p>比如Max Degree (路数)是3的时候，我们插入数据1、2、3,在插入3的时候, 本来应该在第一个磁盘块，但是如果一个节点有三个关键字的时候，意味着有4个指针, 子节点会变成4路，所以这个时候必须进行分裂。把中间的数据2提上去，把1和3变 成2的子节点。</p>
<p>如果删除节点，会有相反的合并的操作。</p>
<p>注意这里是分裂和合并，跟AVL树的左旋和右旋是不一样的。</p>
<p>我们继续插入4和5，B Tree又会出现分裂和合并的操作。</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830806.png">

<p>从这个里面我们也能看到，在更新索引的时候会有大量的索引的结构的调整，所以 解释了为什么我们不要在频繁更新的列上建索引，或者为什么不要更新主键。节点的分裂和合并，其实就是InnoDB页的分裂和合并。</p>
<p>如果索引键值有序，写满一页接着开辟一个新的页：</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830807.png">

<p>如果索引键值无序，存储过程造成大量磁盘碎片，带来频繁的page分裂和合并：</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830808.png">

<h3 id="B-树（加强版多路平衡查找树）"><a href="#B-树（加强版多路平衡查找树）" class="headerlink" title="B+树（加强版多路平衡查找树）"></a>B+树（加强版多路平衡查找树）</h3><p>B Tree的效率已经很高了，为什么MySQL还要对B Tree进行改良，最终使用了B+Tree 呢？</p>
<p>总体上来说，这个B树的改良版本解决的问题比B Tree更全面。</p>
<p>我们来看一下InnoDB里面的B+树的存储结构：</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830809.png">

<p><code>MySQL</code>中的B+Tree有几个特点：</p>
<ul>
<li><p>它的关键字的数量是跟路数相等的。</p>
</li>
<li><p>B+Tree的根节点和枝节点中都不会存储数据，只有叶子节点才存储数据。 目前我们的认知：这里要存放的数据是什么？是完整记录的地址。搜索到关键字不会直接返回，会到最后一层的叶子节点。比如我们搜索id=28, 虽然在第一层直接命中了，但是全部的数据在叶子节点上面，所以我还要继续往下搜 索，一直到叶子节点。</p>
</li>
<li><p>B+Tree的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个 数据会指向下一个叶子节点的第一个数据,形成了一个有序链表的结构。</p>
</li>
</ul>
<p>我们来看一下B+Tree的数据搜寻过程：</p>
<ul>
<li><p>比如我们要查找28,在根节点就找到了键值，但是因为它不是页子节点，所以 会继续往下搜寻，28是［28,66）的左闭右开的区间的临界值，所以会走中间的子节点，然 后继续搜索，它又是［28,34）的左闭右开的区间的临界值，所以会走左边的子节点，最后 在叶子节点上找到了需要的数据。</p>
</li>
<li><p>第二个，如果是范围查询，比如要查询从22到60的数据，当找到22之后，只 需要顺着节点和指针顺序遍历就可以一次性访问到所有的数据节点，这样就极大地提高 了区间查询效率（不需要返回上层父节点重复遍历查找）。</p>
</li>
</ul>
<p>总结一下，<code>InnoDB</code>中的B+Tree特性带来的优势：</p>
<ul>
<li>它是<code>BTree</code>的变种，<code>BTree</code>能解决的问题，它都能解决。B Tree解决的两大问题 是什么？（每个节点存储更多关键字；路数更多）。</li>
<li>扫库、扫表能力更强（如果我们要对表进行全表扫描，只需要遍历叶子节点就可以 了，不需要遍历整棵B+Tree拿到所有的数据）。</li>
<li>B+Tree的磁盘读写能力相对于B Tree来说更强（根节点和枝节点不保存数据区, 所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）。</li>
<li>排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表）。</li>
<li>效率更加稳定（B+Tree永远是在叶子节点拿到数据，所以IO次数是稳定的）。</li>
</ul>
<p>我们举个例子：假设一条记录是<code>16bytes</code>, 一个叶子节点（一页）可以存储10条记 录。非叶子节点可以存储多少个指针？</p>
<p>假设索弓I字段+指针大小为16字节。非叶子节点（一页）可以存储1000个这样的 单元（键值+指针），代表有1000个指针。</p>
<p>树深度为2的时候，有1000^2个叶子节点，可以存储的数据为1000<code>*</code>1000<code>*</code>10=10000000 （千万级别）。</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830810.png">

<p>在査找数据时一次页的査找代表一次IO,也就是说，一张千万级别的表，査询数据 最多需要访问3次磁盘。</p>
<p>树的深度是怎么来的？根据你的键值类型和数据量计算出来的。字段值越大、数据 量越大，深度越大。</p>
<p>所以在<code>InnoDB</code>中B+树深度一般为1-3层，它就能满足千万级的数据存储。</p>
<h3 id="为什么不用红黑树"><a href="#为什么不用红黑树" class="headerlink" title="为什么不用红黑树"></a>为什么不用红黑树</h3><p>红黑树也是BST树，但是不是严格平衡的，通过变色和旋转来保持平衡。必须满足5个约束：</p>
<ul>
<li>节点分为红色或者黑色。</li>
<li>根节点必须是黑色的。</li>
<li>叶子节点都是黑色的<code>NULL</code>节点。</li>
<li>红色节点的两个子节点都是黑色（不允许两个相邻的红色节点）。</li>
<li>从任意节点出发，到其每个叶子节点的路径中包含相同数量的黑色节点。 插入：60、56、68、45、64、 58、72、43、49</li>
</ul>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830814.png">

<p>基于以上规则，可以推导出：从根节点到叶子节点的最长路径（红黑相间的路径）不大于最短路径（全部是黑色节点）的2倍。</p>
<p>为什么不用红黑树？ 1、只有两路；2、不够平衡。红黑树一般只放在内存里面用。例如Java的TreeMap，它可以用来实现一致性哈希。</p>
<h3 id="索引方式：真的是用的B-Tree吗"><a href="#索引方式：真的是用的B-Tree吗" class="headerlink" title="索引方式：真的是用的B+Tree吗?"></a>索引方式：真的是用的B+Tree吗?</h3><p><code>Navicat</code>的工具中，创建索引，索引方式有两种。</p>
<p>HASH：以KV的形式检索数据，也就是说，它会根据索引字段生成哈希码和指针，指针指向数据。</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830815.png">



<h2 id="B-Tree落地形式"><a href="#B-Tree落地形式" class="headerlink" title="B+Tree落地形式"></a>B+Tree落地形式</h2><h3 id="MySQL-架构"><a href="#MySQL-架构" class="headerlink" title="MySQL 架构"></a>MySQL 架构</h3><p>MySQL是一个支持插件式存储引擎的数据库，在MySQL里 面，每个表在创建的时候都可以指定它所使用的存储引擎。</p>
<h3 id="MySQL数据存储文件"><a href="#MySQL数据存储文件" class="headerlink" title="MySQL数据存储文件"></a>MySQL数据存储文件</h3><p>MySQL的数据都是文件的形式存放在磁盘中的，我们可以找到这个数据目录的地址。在MySQL中有这么一个参数，我们来看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show VARIABLES LIKE &#39;datadir;</span><br></pre></td></tr></table></figure>

<p>每个数据库有一个目录，我们新建了一个叫做<code>test</code>的数据库，那么这里就有一个<code>test</code>的文件夹。这个数据库里面我们又建了5张表：<code>archive</code>，<code>innodb</code>，<code>memory</code>，<code>myisam</code>，<code>csvo</code>。</p>
<p>我们进入<code>test</code>的目录，发现这里面有一些跟我们创建的表名对应的文件。在这里我们能看到，每张InnoDB的表有两个文件（.frm和.ibd） , MylSAM的表有三个文件（.frm、.MYD、,MYI）。有一个是相同的文件<code>.frm</code>，<code>.frm</code>是MySQL里面表结构定义的文件，不管你建表的时候选用任何一个存储引擎都会生成。</p>
<h3 id="MylSAM"><a href="#MylSAM" class="headerlink" title="MylSAM"></a>MylSAM</h3><p>在MylSAM里面，另外有两个文件：一个是<code>.MYD</code>文件，D代表Data,是MylSAM的数据文件，存放数据记录，比如我们的user myisam表的所有的表数据。一个是<code>.MYI</code>文件，I代表Index，是MylSAM的索引文件，存放索引，比如我们在 id字段上面创建了一个主键索引，那么主键索引就是在这个索引文件里面。一个索引就 会有一棵<code>B+Tree</code>,所有的<code>B+Tree</code>都在这个<code>.MYI</code>文件里面。也就是说，在MylSAM里面，索引和数据是两个独立的文件。MylSAM的<code>B+Tree</code>里面，叶子节点存储的是数据文件对应的磁盘地址。所以从索 引文件<code>.MYI</code>中找到键值后，会到数据文件<code>.MYD</code>中获取相应的数据记录。</p>
<blockquote>
<p>图</p>
</blockquote>
<p>在<code>MylSAM</code>里面，其他的索引也在这个<code>.MYI</code>文件里面。</p>
<p>非主键索引跟主键索引存储和检索数据的方式是没有任何区别的，一样是在索引文 件里面找到磁盘地址，然后到数据文件里面获取数据。</p>
<blockquote>
<p>图</p>
</blockquote>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>在<code>InnoDB</code>的某个索引的叶子节点上，它直接存储了我们的数据。 所以，为什么说在<code>InnoDB</code>中索引即数据，数据即索引，就是这个原因。</p>
<p>但是这里会有一个问题，一张<code>InnoDB</code>的表可能有很多个多索引，数据肯定是只有—份的，那数据在哪个索引的叶子节点上呢？</p>
<blockquote>
<p>图</p>
</blockquote>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>索引键值的逻辑顺序跟表数据行的物理存储顺序是一致的。<code>InnoDB</code>组织数据的方式就是（聚集）索引组织表（clustered index organize table）。如果说一张表创建了主键索引，那么这个主键索引就是聚集索引，决定数据行的物理存储顺序（比如字典的目录是按拼音排序的，内容也是按拼音排序的，按拼音排序的这种目 录就叫聚集索引）。</p>
<p>那主键索引之外的索引，会不会也把完整记录在叶子节点放一份呢？并不会，因为这会带来额外的存储空间浪费和计算消耗。它们的叶子节点上没有数据怎么检索完整数据？比如我们在name字段上面建的普通索引。</p>
<blockquote>
<p>图</p>
</blockquote>
<p><code>InnoDB</code>中，主键索引和辅助索引是有一个主次之分的。刚才我们讲了，如果有主键索引，那么主键索引就是聚集索引。其他的索引统一叫做<code>二级索引（secondary index）</code>。二级索引存储的是二级索引的键值，例如在name上建立索引，节点上存的是name 的值，qingshanmictom等等（很明显，它的键值逻辑顺序跟物理行的顺序不一致）。而二级索引的叶子节点存的是这条记录对应的主键的值。比如qingshan id = 1，jack id=4所以，二级索引检索数据的流程是这样的：</p>
<p>当我们用name索引查询一条记录，它会在二级索引的叶子节点找到 name=qingshan,拿到主键值，也就是id = 1,然后再到主键索引的叶子节点拿到数据。</p>
<p>为什么不存地址而是存键值？因为地址会变化。从这个角度来说，因为主键索引比二级索引少扫描了一棵B+Tree （避免了回表）， 它的速度相对会快一些。</p>
<p>但是，如果一张表没有主键怎么办？那完整的记录放在哪个索引的叶子节点？或者, 这张表根本没有索引呢？数据放在哪里？</p>
<ul>
<li>如果我们定义了主键(PRIMARY KEY),那么<code>InnoDB</code>会选择主键作为聚集索弘</li>
<li>如果没有显式定义主键，则<code>InnoDB</code>会选择第一个不包含有NULL值的唯一索引 作为主键索引。</li>
<li>如果也没有这样的唯一索引，则<code>InnoDB</code>会选择内置6字节长的<code>ROWID</code>作为隐藏的聚集索引，它会随着行记录的写入而主键递增。</li>
</ul>
<h2 id="索引使用原则"><a href="#索引使用原则" class="headerlink" title="索引使用原则"></a>索引使用原则</h2><h3 id="列的离散度"><a href="#列的离散度" class="headerlink" title="列的离散度"></a>列的离散度</h3><p>第一个叫做列的离散度，我们先来看一下列的离散度的公式：count(distinct(column name))：count（*)，列的全部不同值和所有数据行的比例。数据行数相同的情况下，分子越大，列的离散度就越高。</p>
<p>数据行数相同的情况下，分子越大，列的离散度就越高。</p>
<p>按照这个定义，name的离散度更高，还是gender的离散度更高?</p>
<p>简单来说，如果列的重复值越多，离散度就越低，重复值越少，离散度就越高。</p>
<p>我们不建议大家在离散度低的字段上建立索引。</p>
<p>简单来说，如果列的重复值越多，离散度就越低，重复值越少，离散度就越高。</p>
<p>我们不建议大家在离散度低的字段上建立索引。</p>
<p>如果在B+Tree里面的重复值太多，MySQL的优化器发现走索引跟使用全表扫描差不了多少的时候，就算建了索引，也不一定会走索引。</p>
<h3 id="联合索引最左匹配"><a href="#联合索引最左匹配" class="headerlink" title="联合索引最左匹配"></a>联合索引最左匹配</h3><p>前面我们说的都是针对单列创建的索引，但有的时候我们的多条件査询的时候，也会建立联合索引。单列索引可以看成是特殊的联合索引。比如我们在user表上面，给name和phone建立了一个联合索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user_innodb DROP INDEX comidx_name_phone;</span><br><span class="line">ALTER TABLE user_innodb ADD INDEX comidx_name_phone (name,phone);</span><br></pre></td></tr></table></figure>

<p>联合索引在<code>B+Tree</code>中是复合的数据结构，它是按照从左到右的顺序来建立搜索树的 （name在左边，phone在右边）。</p>
<p>从这张图可以看岀来，name是有序的，phone是无序的。当name相等的时候， phone才是有序的。</p>
<p>这个时候我们使用<code>where name = &#39;test&#39; and phone = &#39;136xx&#39;</code>去査询数据的时候，<code>B+Tree</code>会优先比较<code>name</code>来确定下一步应该搜索的方向，往左还是往右。如果<code>name</code>相同的时候再比较<code>phoneo</code>但是如果查询条件没有<code>name</code>,就不知道第一步应该查哪个 节点，因为建立搜索树的时候name是第一个比较因子，所以用不到索引。</p>
<p>所以，我们在建立联合索引的时候，一定要把最常用的列放在最左边。</p>
<p>比如下面的三条语句，大家觉得用到联合索引了吗？</p>
<ul>
<li>使用两个字段，用到联合索引：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM user_innodb WHERE name&#x3D;&#39;test&#39;AND phone &#x3D; 45204661800&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用左边的name字段，用到联合索引：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM user_nnodb WHERE name&#x3D;&#39;test&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用右边的phone字段，无法使用索引，全表扫描：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM user_innodb WHERE phone &#x3D; &#39;15204661800&#39;</span><br></pre></td></tr></table></figure>

<h4 id="如何创建联合索引"><a href="#如何创建联合索引" class="headerlink" title="如何创建联合索引"></a>如何创建联合索引</h4><p>一个查询创建一个索引，所以我们针对这两条SQL创建了两个索引，这种做法觉得正确？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX idx_name on user_innodb(name);</span><br><span class="line">CREATE INDEX idx_name_phone on user_innodb(name,phone);</span><br></pre></td></tr></table></figure>

<p>当我们创建一个联合索引的时候，按照最左匹配原则，用左边的字段name去査询 的时候，也能用到索引，所以第一个索引完全没必要。</p>
<p>相当于建立了两个联合索引(name)，(name,phone)。如果我们创建三个字段的索引index(a,b,c),相当于创建三个索引：index(a)，index(a,b)，index(a/b/c)。用<code>where b=？和where b=? and c=?</code>是不能使用到索引的。</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>回表：非主键索引，我们先通过索引找到主键索引的键值，再通过主键值查出索引里面没有的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user_innodb where name &#x3D; &#39;Will&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>图</p>
</blockquote>
<p>在二级索引里面，不管是单列索引还是联合索引，如果select的数据列只用从索引中就能够取到，不必从数据区中读取，这时候使用的索引就叫做覆盖索引，这样就避免 了回表。首先创建一个联合索引；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建联合索引</span><br><span class="line">ALTER TABLE user_innodb DROP INDEX comixd_name_phone;</span><br><span class="line">CREATE INDEX comixd_name_phone ON user_innodb (name, phone);</span><br><span class="line"># alter table user_innodb add index comixd_name_phone (name, phone);</span><br></pre></td></tr></table></figure>

<p>Extra里面值为”Using index”代表属于覆盖索引的情况。</p>
<img src="/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/image-20210622005830811.png">

<p>这三个查询语句属于覆盖索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT name,phone FROM user_innodb WHERE name &#x3D;&#39;test&#39; AND phone &#x3D; &#39;13666666666&#39;;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT name FROM user_innodb WHERE name &#x3D; &#39;青山&#39; AND phone &#x3D; &#39;113666666666&#39;;</span><br><span class="line"></span><br><span class="line">EXPLAIN SELECT phone FROM user_innodb WHERE name &#x3D; &#39;青山&#39; AND phone &#x3D; &#39;13666666666&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>select * ，不是覆盖索引。</p>
</blockquote>
<p>如果改成只用where phone =査询呢？按照我们之前的分析，它是用不到索引的。实际上可以用到覆盖索引，优化器觉得用索引更快，所以还是用到了索引。很明显，因为覆盖索引减少了I/O次数，减少了数据的访问量，可以大大地提升查询效率。</p>
<h3 id="索引条件下推（ICP）"><a href="#索引条件下推（ICP）" class="headerlink" title="索引条件下推（ICP）"></a>索引条件下推（<code>ICP</code>）</h3><p>索引条件下推(Index Condition Pushdown) ，<code>5.6</code>以后完善的功能。只适用于二级索引。<code>ICP</code>的目标是减少访问表的完整行的读数量从而减少I/O操作。这里说的下推，其实是意思是把过滤的动作在存储引擎做完，而不需要到Server层过滤。再来看这么一张表，在<code>last_name</code>和<code>first_name</code>上面创建联合索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists employees;</span><br><span class="line">create table employees</span><br><span class="line">(</span><br><span class="line">    emp_no     int(11) auto_increment NOT NULL,</span><br><span class="line">    birth_date date                   NULL,</span><br><span class="line">    first_name varchar(14)            NOT NULL,</span><br><span class="line">    last_name  varchar(16)            NOT NULL,</span><br><span class="line">    gender     enum (&#39;M&#39;,&#39;F&#39;)         NOT NULL,</span><br><span class="line">    hire_date  date                   NULL,</span><br><span class="line">    PRIMARY KEY (emp_no)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; latin1;</span><br><span class="line"></span><br><span class="line">alter table employees</span><br><span class="line">    add index idx_lastname_firstname (last_name, first_name);</span><br><span class="line"></span><br><span class="line">INSERT INTO employees(birth_date, first_name, last_name, gender, hire_date)</span><br><span class="line">VALUES (current_date, &#39;698&#39;, &#39;liu&#39;, &#39;F&#39;, current_date);</span><br><span class="line">INSERT INTO employees(birth_date, first_name, last_name, gender, hire_date)</span><br><span class="line">VALUES (NULL, &#39;d99&#39;, &#39;zheng&#39;, &#39;F&#39;, NULL);</span><br><span class="line">INSERT INTO employees(birth_date, first_name, last_name, gender, hire_date)</span><br><span class="line">VALUES (NULL, &#39;e08&#39;, &#39;liuang&#39;, &#39;F&#39;, NULL);</span><br><span class="line">INSERT INTO employees(birth_date, first_name, last_name, gender, hire_date)</span><br><span class="line">VALUES (NULL, &#39; 59d&#39;, &#39;lu&#39;, &#39;F&#39;, NULL);</span><br><span class="line">INSERT INTO employees(birth_date, first_name, last_name, gender, hire_date)</span><br><span class="line">VALUES (NULL, &#39;989&#39;, &#39;yu&#39;, &#39;F&#39;, NULL);</span><br></pre></td></tr></table></figure>

<p>现在我们要査询所有姓<code>wang</code>，并且名字最后一个字是<code>zi</code>的员工，比如王胖子，王瘦子。查询的SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from employees where last_name &#x3D; &#39;wang&#39; and first_name LIKE &#39;%zi&#39;;</span><br></pre></td></tr></table></figure>

<p>正常情况来说，因为字符是从左往右排序的，当你把<code>％</code>加在前面的时候，是不能基于 索引去比较的，所以只有<code>last_name </code>（姓）这个字段能够用于索引比较和过滤。</p>
<p>所以查询过程是这样的：</p>
<ul>
<li>根据联合索引查出所有姓<code>wang</code>的二级索引数据（3个主键值：6、7、8）。</li>
<li> 回表，到主键索引上查询全部符合条件的数据（3条数据）。</li>
<li>把这3条数据返回给Server层，在Server层过滤出名字以<code>zi</code>结尾的员工。</li>
</ul>
<blockquote>
<p>图</p>
</blockquote>
<h2 id="索引的创建与使用"><a href="#索引的创建与使用" class="headerlink" title="索引的创建与使用"></a>索引的创建与使用</h2><h3 id="索引创建"><a href="#索引创建" class="headerlink" title="索引创建"></a>索引创建</h3><ul>
<li>在用于where判断order排序和join的(on)、group by的字段上创建索引</li>
<li>索引的个数不要过多。（浪费空间，更新变慢）</li>
<li>过长的字段，建立前缀索引。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#39;pre_test&#39;</span><br><span class="line">(</span><br><span class="line">    &#39;content&#39; varchar(20) DEFAULT NULL,</span><br><span class="line">    KEY &#39; pre_idx&#39; (&#39;content&#39; (6))</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8mb4;</span><br></pre></td></tr></table></figure>

<ul>
<li>区分度低的字段，例如性别，不要建索引。（离散度太低，导致扫描行数过多）</li>
<li>频繁更新的值，不要作为主键或者索引。（页分裂）</li>
<li>随机无序的值，不建议作为索引，例如身份证、<code>UUID</code>。（无序，分裂）</li>
<li>组合索引把散列性高(区分度高)的值放在前面。</li>
<li>创建复合索引，而不是修改单列索引。</li>
</ul>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul>
<li><p>索引列上使用函数(<code>replace</code>`substr<code>\</code>concat<code>\</code>sum<code> </code>count<code> </code>avg<code>)、表达式计算(</code>+<code>  </code>-<code> </code>*<code> </code>/`)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT * FROM t2 where id+1 &#x3D; 4;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串不加引号，出现隐式转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE user_innodb DROP INDEX comidx_name_hone;</span><br><span class="line">ALTER TABLE user innodb add INDEX comidx_name_phone (name,phone);</span><br><span class="line"></span><br><span class="line">explain SELECT * FROM user_innodb where name &#x3D; 136;</span><br><span class="line">explain SELECT * FROM user_innodb where name &#x3D; &#39;136&#39;;</span><br></pre></td></tr></table></figure></li>
<li><p><code>like</code>条件中前面带<code>%</code>，<code>where</code>条件中<code>like abc%</code>，<code>like %2673%</code>, <code>like %888</code>都用不到索引吗？为什么?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from user_innodb where name like &#39;wang%&#39;;</span><br><span class="line">explain select * from user_innodb where name like &#39;%wang&#39;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>过滤的开销太大。这个时候可以用全文索引。</p>
</blockquote>
</li>
<li><p>负向查询</p>
<ul>
<li><code>NOT LIKE</code>不能：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select * from employees where last_name not like &#39;wang&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>(&lt;&gt;)</code>和<code>NOT IN</code>在某些情况下可以:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain select * from employees where emp_no not in (1);</span><br><span class="line">explain select * from employees where emp_no &lt;&gt; 1;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个例子中，因为索引是有序的，只要从1之后开始顺序读取就行了。</p>
</blockquote>
</li>
</ul>
<p>注意跟数据库版本、数据量、数据选择度都有关系。其实，用不用索引，最终都是优化器说了算。</p>
<p>优化器是基于什么的优化器呢？</p>
<p>基于 cost 开销(Cost Base Optimizer)，它不是基于规则(Rule-Based Optimizer),，也不是基于语义。怎么样开销小就怎么来。</p>
<p>使用索引有基本原则，但是没有具体细则，没有什么情况一定用索引，什么情况一 定不用索引的规则。</p>
<h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q &amp; A"></a>Q &amp; A</h2><h3 id="Q1：哈希索引有什么特点呢？"><a href="#Q1：哈希索引有什么特点呢？" class="headerlink" title="Q1：哈希索引有什么特点呢？"></a>Q1：哈希索引有什么特点呢？</h3><ul>
<li><p>它的时间复杂度是o(1),査询速度比较快。因为哈希索引里面的数据不是按顺序存储的，所以不能用于排序。</p>
</li>
<li><p>我们在查询数据的时候要根据键值计算哈希码，所以它只能支持等值查询 (=IN)，不支持范围查询（<code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>between</code> <code>and</code>）。</p>
</li>
<li><p>如果字段重复值很多的时候，会出现大量的哈希冲突(采用拉链法解 决)，效率会降低。</p>
</li>
</ul>
<blockquote>
<p>在InnoDB中，不能显式地创建一个哈希索引（所谓的支持哈希索 引指的是AHI,自适应哈希，它是InnoDB自动为buffer pool中的热点页创建的索引）。memory存储引擎可以使用Hash索引。</p>
</blockquote>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>spearmint
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://sys-spearmint.github.io/2021/07/07/Mysql%E7%B4%A2%E5%BC%95/" title="Mysql Index">https://sys-spearmint.github.io/2021/07/07/Mysql索引/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Mysql/" rel="tag"><i class="fa fa-tag"></i> Mysql</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/06/13/Mysql%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81/" rel="prev" title="Mysql transaction and lock">
                  <i class="fa fa-chevron-left"></i> Mysql transaction and lock
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div><script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">spearmint</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">78k</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/third-party/search/local-search.js"></script>






  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{&quot;enable&quot;:true,&quot;repo&quot;:&quot;sys-spearmint&#x2F;sys-spearmint.github.io&quot;,&quot;issue_term&quot;:&quot;pathname&quot;,&quot;theme&quot;:&quot;github-light&quot;,&quot;cdn&quot;:&quot;https:&#x2F;&#x2F;utteranc.es&#x2F;client.js&quot;}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
